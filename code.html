<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Code Walkthrough</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- MathJax -->
<script>
window.MathJax = {
  tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
  svg: { fontCache: 'global' }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

<style>
body {
    margin: 0;
    font-family: "Segoe UI", Arial, sans-serif;
    background: #0f1117;
    color: #e6edf3;
    line-height: 1.75;
}

nav {
    background: #161b22;
    padding: 15px 40px;
}

nav a {
    color: #58a6ff;
    text-decoration: none;
    margin-right: 25px;
    font-weight: 500;
}

nav a:hover {
    text-decoration: underline;
}

.container {
    max-width: 1000px;
    margin: 60px auto;
    padding: 0 20px;
}

h1 {
    color: #79c0ff;
}

h2 {
    margin-top: 50px;
    color: #58a6ff;
}

.code-box {
    background: #161b22;
    padding: 18px;
    border-radius: 8px;
    margin: 20px 0;
    overflow-x: auto;
    font-family: monospace;
    font-size: 14px;
}

.full-code {
    max-height: 500px;
    overflow-y: scroll;
}
</style>
</head>

<body>

<nav>
    <a href="index.html">Home</a>
    <a href="simulation.html">Simulation</a>
    <a href="model.html">Model</a>
    <a href="code.html">Code Walkthrough</a>
</nav>

<div class="container">

<h1>Code Walkthrough</h1>

<p>
This section presents a structured explanation of the simulation implementation. 
The program is organized into logical stages that directly correspond to the mathematical formulation: 
parameter definition, initialization, force evaluation, time evolution, energy computation, and rendering.
</p>

<hr>

<h2>1. Parameter Definition</h2>

<p>
All simulation parameters are defined within a configuration object. These control the physical dynamics and visualization behaviour of the system.
</p>

<div class="code-box">
const settings = {
    numColors: 4,
    atomsPerColor: 250,
    interactionRadius: 80,
    viscosity: 0.6,
    timeScale: 1.0,
    gravity: 0.0,
    maxSpeed: 4,
    glow: true,
    trails: true,
    showEnergy: true
};
</div>

<p>
These correspond to the mathematical quantities:
</p>

<ul>
<li>Interaction radius → \( R_s \)</li>
<li>Viscosity (damping) → \( \eta \)</li>
<li>Time step scaling → \( \Delta t \)</li>
<li>Gravity → external acceleration term</li>
</ul>

<hr>

<h2>2. System Initialization</h2>

<p>
The simulation begins by constructing a species interaction matrix and initializing particle states.
Each interaction coefficient is assigned a value in the interval [-1, 1].
</p>

<div class="code-box">
function initRules() {
    for (let i = 0; i < settings.numColors; i++) {
        rules[i] = [];
        for (let j = 0; j < settings.numColors; j++) {
            rules[i][j] = Math.random() * 2 - 1;
        }
    }
}
</div>

<p>
Particles are then placed at random positions within the simulation domain with zero initial velocity.
</p>

<hr>

<h2>3. Force Evaluation</h2>

<p>
For each unordered particle pair, the Euclidean distance is computed. If the separation is less than the interaction radius,
a linear distance-dependent force is applied.
</p>

<div class="code-box">
const dx = b.x - a.x;
const dy = b.y - a.y;
const dist2 = dx * dx + dy * dy;

if (dist2 < r * r) {
    const dist = Math.sqrt(dist2);
    const strength = rules[a.color][b.color] * (1 - dist / r);
}
</div>

<p>
This implements the force law
</p>

\[
F \propto A_{ij} \left( 1 - \frac{d}{R} \right)
\]

<p>
Equal and opposite forces are applied to preserve symmetry.
</p>

<hr>

<h2>4. Velocity Update</h2>

<p>
After computing the net force on each particle, velocities are updated using a damped integration rule.
</p>

<div class="code-box">
a.vx *= (1 - settings.viscosity);
a.vy *= (1 - settings.viscosity);
a.vy += settings.gravity;
</div>

<p>
Velocity magnitude is constrained to maintain numerical stability.
</p>

<hr>

<h2>5. Position Update</h2>

<div class="code-box">
a.x += a.vx * settings.timeScale;
a.y += a.vy * settings.timeScale;
</div>

<p>
Reflective boundary conditions ensure particles remain within the domain.
</p>

<hr>

<h2>6. Energy Computation</h2>

\[
E = \frac{1}{2} \sum_{i=1}^{N} \left( v_{x,i}^2 + v_{y,i}^2 \right)
\]

<p>
This provides a global measure of dynamical activity.
</p>

<hr>

<h2>7. Rendering</h2>

<div class="code-box">
ctx.beginPath();
ctx.arc(a.x, a.y, 2, 0, Math.PI * 2);
ctx.fill();
</div>

<p>
Rendering is independent of the physical simulation and serves only for visualization.
</p>

<hr>

<h2>Complete Source Code</h2>

<p>
The complete implementation is provided below for verification and reference.
</p>

<div class="code-box full-code">

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Particle Life&lt;/title&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;style&gt;
body { margin: 0; overflow: hidden; background: black; }
canvas { display: block; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;canvas id="canvas"&gt;&lt;/canvas&gt;

&lt;script&gt;

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

const predefinedColors = ["green","red","orange","cyan","magenta","lavender","teal"];

const settings = {
    numColors: 4,
    atomsPerColor: 250,
    interactionRadius: 80,
    viscosity: 0.6,
    timeScale: 1.0,
    gravity: 0.0,
    maxSpeed: 4
};

let atoms = [];
let rules = [];

function initRules() {
    rules = [];
    for (let i = 0; i &lt; settings.numColors; i++) {
        rules[i] = [];
        for (let j = 0; j &lt; settings.numColors; j++) {
            rules[i][j] = Math.random() * 2 - 1;
        }
    }
}

function initAtoms() {
    atoms = [];
    for (let c = 0; c &lt; settings.numColors; c++) {
        for (let i = 0; i &lt; settings.atomsPerColor; i++) {
            atoms.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: 0,
                vy: 0,
                color: c
            });
        }
    }
}

function applyForces() {
    for (let i = 0; i &lt; atoms.length; i++) {
        const a = atoms[i];
        for (let j = i + 1; j &lt; atoms.length; j++) {
            const b = atoms[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist2 = dx * dx + dy * dy;

            if (dist2 &gt; 0 &amp;&amp; dist2 &lt; settings.interactionRadius ** 2) {
                const dist = Math.sqrt(dist2);
                const strength = rules[a.color][b.color] *
                                 (1 - dist / settings.interactionRadius);

                const fx = strength * dx / dist;
                const fy = strength * dy / dist;

                a.vx += fx;
                a.vy += fy;
                b.vx -= fx;
                b.vy -= fy;
            }
        }
    }

    for (const a of atoms) {
        a.vx *= (1 - settings.viscosity);
        a.vy *= (1 - settings.viscosity);
        a.vy += settings.gravity;

        const speed = Math.sqrt(a.vx*a.vx + a.vy*a.vy);
        if (speed &gt; settings.maxSpeed) {
            a.vx *= settings.maxSpeed / speed;
            a.vy *= settings.maxSpeed / speed;
        }

        a.x += a.vx * settings.timeScale;
        a.y += a.vy * settings.timeScale;

        if (a.x &lt; 0 || a.x &gt; canvas.width) a.vx *= -1;
        if (a.y &lt; 0 || a.y &gt; canvas.height) a.vy *= -1;
    }
}

function draw() {
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    for (const a of atoms) {
        ctx.fillStyle = predefinedColors[a.color];
        ctx.beginPath();
        ctx.arc(a.x,a.y,2,0,Math.PI*2);
        ctx.fill();
    }
}

function update() {
    applyForces();
    draw();
    requestAnimationFrame(update);
}

initRules();
initAtoms();
update();

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</div>

</div>
</body>
</html>


