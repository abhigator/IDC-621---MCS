<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Code Walkthrough</title>

<style>
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background-color: #0b0f1a;
    color: #d6e2ff;
}

nav {
    padding: 15px;
    background-color: #111827;
}

nav a {
    color: #6cb4ff;
    margin-right: 20px;
    text-decoration: none;
    font-weight: bold;
}

.container {
    max-width: 900px;
    margin: 40px auto;
    padding: 20px;
}

h1, h2, h3 {
    color: #6cb4ff;
}

hr {
    border: 0;
    height: 1px;
    background: #2a344a;
    margin: 40px 0;
}

.code-box {
    background-color: #111827;
    padding: 15px;
    border-radius: 8px;
    overflow-x: auto;
}

.full-code {
    max-height: 500px;
    overflow-y: scroll;
}

pre {
    margin: 0;
    white-space: pre-wrap;
}

code {
    font-family: Consolas, monospace;
    font-size: 0.9rem;
}

a {
    color: #6cb4ff;
}
</style>
</head>

<body>

<nav>
    <a href="index.html">Home</a>
    <a href="simulation.html">Simulation</a>
    <a href="model.html">Model</a>
    <a href="code.html">Code Walkthrough</a>
</nav>

<div class="container">

<h1>Code Walkthrough</h1>

<p>
This section explains the logical and structural organisation of the simulation.
Each part of the implementation corresponds directly to the mathematical model
described earlier.
</p>

<hr>

<h2>1. Configuration Parameters</h2>

<p>
All physical and visual parameters are defined inside a configuration object.
These control species count, interaction strength, damping, and integration scale.
</p>

<div class="code-box">
<pre><code>
const settings = {
    numColors: 4,
    atomsPerColor: 250,
    interactionRadius: 80,
    viscosity: 0.6,
    timeScale: 1.0,
    gravity: 0.0,
    maxSpeed: 4
};
</code></pre>
</div>

<hr>

<h2>2. Initialisation</h2>

<p>
The interaction matrix is generated first. Each species pair is assigned
a random interaction coefficient in the interval [-1, 1]. Positive values
produce attraction, while negative values produce repulsion.
</p>

<div class="code-box">
<pre><code>
function initRules() {
    rules = [];
    for (let i = 0; i < settings.numColors; i++) {
        rules[i] = [];
        for (let j = 0; j < settings.numColors; j++) {
            rules[i][j] = Math.random() * 2 - 1;
        }
    }
}
</code></pre>
</div>

<p>
Particles are then initialised with random spatial positions and zero velocity.
Each particle is assigned a species index corresponding to its colour group.
</p>

<div class="code-box">
<pre><code>
function initAtoms() {
    atoms = [];
    for (let c = 0; c < settings.numColors; c++) {
        for (let i = 0; i < settings.atomsPerColor; i++) {
            atoms.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: 0,
                vy: 0,
                color: c
            });
        }
    }
}
</code></pre>
</div>

<hr>


<h2>3. Force Computation</h2>

<p>
For each unordered pair of particles, the separation vector and squared distance
are computed. If the separation is smaller than the interaction radius,
a linear distance-dependent force is applied.
</p>

<div class="code-box">
<pre><code>
const dx = b.x - a.x;
const dy = b.y - a.y;
const dist2 = dx * dx + dy * dy;

if (dist2 > 0 && dist2 < settings.interactionRadius ** 2) {

    const dist = Math.sqrt(dist2);

    const strength =
        rules[a.color][b.color] *
        (1 - dist / settings.interactionRadius);

    const fx = strength * dx / dist;
    const fy = strength * dy / dist;

    a.vx += fx;
    a.vy += fy;
    b.vx -= fx;
    b.vy -= fy;
}
</code></pre>
</div>

<p>
The force magnitude decreases linearly with distance and vanishes at the
interaction boundary. Equal and opposite forces preserve symmetry.
</p>

<hr>


<h2>4. Time Integration</h2>

<p>
After computing forces, velocities are updated using damping and optional
external acceleration. The damping term models viscous dissipation.
</p>

<div class="code-box">
<pre><code>
a.vx *= (1 - settings.viscosity);
a.vy *= (1 - settings.viscosity);
a.vy += settings.gravity;
</code></pre>
</div>

<p>
To maintain numerical stability, the velocity magnitude is limited.
</p>

<div class="code-box">
<pre><code>
const speed = Math.sqrt(a.vx*a.vx + a.vy*a.vy);

if (speed > settings.maxSpeed) {
    a.vx *= settings.maxSpeed / speed;
    a.vy *= settings.maxSpeed / speed;
}
</code></pre>
</div>

<p>
Finally, positions are advanced using a discrete-time update rule.
</p>

<div class="code-box">
<pre><code>
a.x += a.vx * settings.timeScale;
a.y += a.vy * settings.timeScale;
</code></pre>
</div>

<hr>


<h2>5. Rendering</h2>

<p>
Rendering is performed independently of the physical computation.
Each particle is drawn as a small circular element on the canvas.
</p>

<hr>

<h2>Complete Source Code</h2>

<p>
The full implementation is provided below for verification and reference.
</p>

<div class="code-box full-code">
<pre><code>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

const predefinedColors = [
    "green", "red", "orange", "cyan",
    "magenta", "lavender", "teal"
];

const settings = {
    numColors: 4,
    atomsPerColor: 250,
    interactionRadius: 80,
    viscosity: 0.6,
    timeScale: 1.0,
    gravity: 0.0,
    maxSpeed: 4
};

let atoms = [];
let rules = [];

function initRules() {
    rules = [];
    for (let i = 0; i < settings.numColors; i++) {
        rules[i] = [];
        for (let j = 0; j < settings.numColors; j++) {
            rules[i][j] = Math.random() * 2 - 1;
        }
    }
}

function initAtoms() {
    atoms = [];
    for (let c = 0; c < settings.numColors; c++) {
        for (let i = 0; i < settings.atomsPerColor; i++) {
            atoms.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: 0,
                vy: 0,
                color: c
            });
        }
    }
}

function applyForces() {
    for (let i = 0; i < atoms.length; i++) {
        const a = atoms[i];
        for (let j = i + 1; j < atoms.length; j++) {
            const b = atoms[j];

            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist2 = dx * dx + dy * dy;

            if (dist2 > 0 && dist2 < settings.interactionRadius ** 2) {

                const dist = Math.sqrt(dist2);
                const strength =
                    rules[a.color][b.color] *
                    (1 - dist / settings.interactionRadius);

                const fx = strength * dx / dist;
                const fy = strength * dy / dist;

                a.vx += fx;
                a.vy += fy;
                b.vx -= fx;
                b.vy -= fy;
            }
        }
    }

    for (const a of atoms) {

        a.vx *= (1 - settings.viscosity);
        a.vy *= (1 - settings.viscosity);
        a.vy += settings.gravity;

        const speed = Math.sqrt(a.vx*a.vx + a.vy*a.vy);

        if (speed > settings.maxSpeed) {
            a.vx *= settings.maxSpeed / speed;
            a.vy *= settings.maxSpeed / speed;
        }

        a.x += a.vx * settings.timeScale;
        a.y += a.vy * settings.timeScale;

        if (a.x < 0 || a.x > canvas.width) a.vx *= -1;
        if (a.y < 0 || a.y > canvas.height) a.vy *= -1;
    }
}

function draw() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (const a of atoms) {
        ctx.fillStyle = predefinedColors[a.color];
        ctx.beginPath();
        ctx.arc(a.x, a.y, 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

function update() {
    applyForces();
    draw();
    requestAnimationFrame(update);
}

initRules();
initAtoms();
update();
</code></pre>
</div>

<hr>

<h2>Inspiration and References</h2>

<p>
This project was inspired by publicly available particle-life simulations
demonstrating emergent self-organization from local interaction rules.
</p>

<ul>
<li>
YouTube Demonstration:
<a href="https://youtu.be/0Kx4Y9TVMGg?si=DjqayfAnl9iS4QOO" target="_blank">
Particle Life Simulation
</a>
</li>

<li>
Original Repository:
<a href="https://github.com/hunar4321/particle-life" target="_blank">
https://github.com/hunar4321/particle-life
</a>
</li>
</ul>

<p>
Coursework Repository:
<a href="https://github.com/abhigator/IDC-621---MCS" target="_blank">
https://github.com/abhigator/IDC-621---MCS
</a>
</p>

</div>

</body>
</html>
